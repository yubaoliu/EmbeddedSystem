#include "LCD_KEY.h"
#include  "systemInit.h"

//  延时N个微秒 
void __delayNuS (int32 iTime)
{
    iTime = SysCtlClockGet() * iTime / 2000000;             //  根据系统时钟速率确定延时
    while (--iTime != 0);
}

//  向SPI 总线写入1 个字节的数据。
void __zlg7289SPIWrite (int8 cDat)
{
    int8 cT = 8;
    GPIOPinTypeOut( LCD_KEY_PORT , LCD_KEY_DIO);            //  设置DIO端口为输出模式
    
    do
    {                                                       //  循环写一个字节的数据
        if((cDat & 0x80) == 0x80)
        {
            GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_DIO, 0xff);
        } 
        else 
        {
            GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_DIO, 0x00);
        }

        cDat <<= 1;
        GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CLK, 0xff);
        __delayNuS(5);
        GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CLK, 0x00);
        __delayNuS(5);

    } while (--cT != 0);
}
 
//  从SPI 总线读取1 个字节的数据
int8 __zlg7289SPIRead (void)
{
    int8 cDat = 0;
    int8 cT   = 8;
    GPIOPinTypeIn( LCD_KEY_PORT, LCD_KEY_DIO);              //  设置DIO端口为输出模式

    do
    {                                                       //  循环读一个字节的数据
        GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CLK, 0xff);
        __delayNuS(5);
        cDat <<= 1;

        if (GPIOPinRead( LCD_KEY_PORT , LCD_KEY_DIO)) 
        {
            cDat++;
        }

        GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CLK, 0x00);
        __delayNuS(5);

    } while (--cT != 0);

    return (cDat);
}

//  执行ZLG7289 纯指令。
void zlg7289Cmd (int8  cCmd)
{
    GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CS, 0x00);
    __delayNuS(25);
    __zlg7289SPIWrite(cCmd);
    GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CS, 0xff);
    __delayNuS(5);
}

//  执行ZLG7289 带数据指令。
void zlg7289CmdDat (uint8  cCmd, int8  cDat)
{
    GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CS, 0x00);
    __delayNuS(25);
    __zlg7289SPIWrite(cCmd);
    __delayNuS(15);
    __zlg7289SPIWrite(cDat);
    GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CS, 0xff);
    __delayNuS(5);
}

//  下载数据。
//  ucMod=0： 下载数据且按方式0 译码
//  ucMod=1： 下载数据且按方式1 译码
//  ucMod=2： 下载数据但不译码
//  cX：      数码管编号（横坐标），取值0～7
//  cDp=0：   小数点不亮
//  cDp=1：   小数点亮
//  cDat：    要显示的数据 
void zlg7289Download (uint8  ucMod, int8  cX, int8  cDp, int8  cDat)
{
    uint8 ucModDat[3] = {0x80,0xC8,0x90};
    uint8 ucD1;
    uint8 ucD2;

    if (ucMod > 2) 
    {
        ucMod = 2;
    }

    ucD1  = ucModDat[ucMod];
    cX   &= 0x07;
    ucD1 |= cX;
    ucD2  = cDat & 0x7F;

    if (cDp  == 1) 
    {
        ucD2 |= 0x80;
    }

    zlg7289CmdDat(ucD1, ucD2);
}

//  执行ZLG7289 键盘命令。
//  返回读到的按键值：0～63。如果返回0xFF 则表示没有键按下
int8 zlg7289Key (void)
{
    int8 cKey;
    GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CS, 0x00);
    __delayNuS(25);
    __zlg7289SPIWrite(0x15);
    __delayNuS(15);
    cKey = __zlg7289SPIRead();
    GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CS, 0xff);
    __delayNuS(5);

    return (cKey);
}

//  ZLG7289 初始化
void zlg7289Init (void)
{
    SysCtlPeripheralEnable( LCD_KEY_PERIPH );               //  使能GPIO B口外设

    GPIOPinTypeIn( LCD_KEY_PORT , LCD_KEY_KEY);             //  设置KEY端口为输入
    GPIOIntTypeSet( LCD_KEY_PORT , LCD_KEY_KEY, GPIO_FALLING_EDGE);
                                                            //  配置引脚下降沿触发中断
    GPIOPinIntEnable( LCD_KEY_PORT , LCD_KEY_KEY);          //  使能引脚输入中断
    IntEnable(INT_GPIOE);   
    
                                    //  使能GPIO PE口中断

    GPIOPinTypeOut( LCD_KEY_PORT , LCD_KEY_CS |LCD_KEY_CLK |LCD_KEY_DIO);     
                                                            //  设置I/O口为输出模式
    GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_DIO, 0xff);
    GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CLK, 0x00);
    GPIOPinWrite( LCD_KEY_PORT , LCD_KEY_CS , 0xff);

    zlg7289Reset();                                         //  复位ZLG7289
}

/*********************************************************************************************************
  END FILE
*********************************************************************************************************/
